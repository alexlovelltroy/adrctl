package adr

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

type Entry struct {
	Number int
	ID     string // zero-padded string (e.g., 0001)
	Title  string
	Status string
	Date   string
	File   string // relative path/filename
}

func Scan(dir string) ([]Entry, error) {
	ents := []Entry{}
	items, err := os.ReadDir(dir)
	if err != nil {
		return nil, err
	}
	for _, it := range items {
		if it.IsDir() || !strings.HasSuffix(it.Name(), ".md") || strings.EqualFold(it.Name(), "index.md") {
			continue
		}
		path := filepath.Join(dir, it.Name())
		meta, err := ParseADR(path)
		if err != nil {
			// Best-effort: attempt to keep going, but include a minimal entry
			if n, ok := parseLeadingNumber(it.Name()); ok {
				ents = append(ents, Entry{Number: n, ID: fmt.Sprintf("%04d", n), Title: it.Name(), Status: "", Date: "", File: it.Name()})
			}
			continue
		}
		ents = append(ents, Entry{
			Number: meta.Number,
			ID:     fmt.Sprintf("%04d", meta.Number),
			Title:  meta.Title,
			Status: meta.Status,
			Date:   meta.Date,
			File:   it.Name(),
		})
	}
	// sort by Number
	sort.Slice(ents, func(i, j int) bool { return ents[i].Number < ents[j].Number })
	return ents, nil
}

func WriteIndex(out string, entries []Entry) error {
	var b strings.Builder
	b.WriteString("# Architecture Decision Records\n\n")
	b.WriteString("This index is generated by `adrctl`. Do not edit manually.\n\n")
	b.WriteString("| ID | Title | Status | Date |\n")
	b.WriteString("|---:|:------|:------:|:-----:|\n")
	for _, e := range entries {
		b.WriteString(fmt.Sprintf("| %s | [%s](./%s) | %s | %s |\n", e.ID, escapePipes(e.Title), e.File, escapePipes(e.Status), escapePipes(e.Date)))
	}

	if err := os.MkdirAll(filepath.Dir(out), 0o755); err != nil {
		return err
	}
	return os.WriteFile(out, []byte(b.String()), 0o644)
}

func escapePipes(s string) string {
	return strings.ReplaceAll(s, "|", "\\|")
}
